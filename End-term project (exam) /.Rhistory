lines(1:3, RMSE$sigma2, col='blue')
lines(1:3, RMSE$theta, col='green')
legend( x = 'topright', legend = names(RMSE), pch=1,
col = c('red', 'orange', 'black', 'blue', 'green'))
### plot time
plot(1:3, time, type ='l')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
plot(NULL, ylab = 'RMSE', xlim=c(0, 4), ylim=c(min(RMSE), max(RMSE)))
lines(1:3, RMSE$mu1, col='red')
lines(1:3, RMSE$sigma1, col='orange')
lines(1:3, RMSE$mu2, col='black')
lines(1:3, RMSE$sigma2, col='blue')
lines(1:3, RMSE$theta, col='green')
legend( x = 'topright', legend = names(RMSE), pch=1,
col = c('red', 'orange', 'black', 'blue', 'green'))
load('fit_n_times.RData')
time
time2 <- data.frame(x=1:3,y=time)
time2
plot(time, type ='l')
plot(time2, type ='l')
time2 <- data.frame(number_of_runs=c(2,5,10) * 100,time=time)
plot(time2, type ='l')
plot(time2, type ='b')
time <- data.frame(number_of_runs=c(2,5,10) * 100,time=time)
RMSE
RMSE$number_of_runs <- c(2,5,10) * 100
RMSE
save(time, RMSE, file = 'fit_n_times.RData')
load('fit_n_times.RData')
### plot time
plot(time, type ='b')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
plot(NULL, ylab = 'RMSE', xlim=c(0, 4), ylim=c(min(RMSE), max(RMSE)))
lines(RMSE$number_of_runs, RMSE$mu1, col='red')
RMSE$number_of_runs
RMSE$number_of_runs <- c(2,5,10) * 100
RMSE
### plot time
plot(time, type ='b')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
plot(NULL, ylab = 'RMSE', xlim=c(0, 4), ylim=c(min(RMSE), max(RMSE)))
lines(RMSE$number_of_runs, RMSE$mu1, col='red')
RMSE$number_of_runs
RMSE
save(time, RMSE, file = 'fit_n_times.RData')
load('fit_n_times.RData')
fit_n_times <- function(n){
##############################
# This function estimates the parameters for 100 times and returns the RMSE
# n: the number of data points in each simulation run
##############################
### simulate
sim_data <- lapply(1:100,function(x) rmycopula(n, 1, 2, 3, 0.5, 2))
results <- c()
for (i in 1:100){
results <- cbind(results, unlist(estimate(sim_data[[i]]$x1, sim_data[[i]]$x2)))
}
### calculate RMSE
(results - c(1, 2, 3, 0.5, 2))^2 %>%
rowMeans(.) %>%
sqrt(.)
}
### initiate time and RMSE
time <- numeric(3)
RMSE <- matrix(0, 3, 5)
### conduct simulation for n = 200,500 and 1000
i <- 1
for (n in c(2,5,10) * 100) {
time[i] <- system.time(RMSE[i,] <- fit_n_times(n))/100 # average computing time
i <- i + 1
}
### update format for plotting
time <- data.frame(number_of_runs=c(2,5,10) * 100, time=time)
RMSE$number_of_runs <- c(2,5,10) * 100
save(time, RMSE, file = 'fit_n_times.RData')
load('fit_n_times.RData')
### plot time
plot(time, type ='b')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta', 'number_of_runs')
plot(NULL, ylab = 'RMSE', xlim=c(0, 4), ylim=c(min(RMSE), max(RMSE)))
lines(RMSE$number_of_runs, RMSE$mu1, col='red')
lines(RMSE$number_of_runs, RMSE$sigma1, col='orange')
lines(RMSE$number_of_runs, RMSE$mu2, col='black')
lines(RMSE$number_of_runs, RMSE$sigma2, col='blue')
lines(RMSE$number_of_runs, RMSE$theta, col='green')
legend( x = 'topright', legend = names(RMSE), pch=1,
col = c('red', 'orange', 'black', 'blue', 'green'))
load('fit_n_times.RData')
RMSE
fit_n_times <- function(n){
##############################
# This function estimates the parameters for 100 times and returns the RMSE
# n: the number of data points in each simulation run
##############################
### simulate
sim_data <- lapply(1:100,function(x) rmycopula(n, 1, 2, 3, 0.5, 2))
results <- c()
for (i in 1:100){
results <- cbind(results, unlist(estimate(sim_data[[i]]$x1, sim_data[[i]]$x2)))
}
### calculate RMSE
(results - c(1, 2, 3, 0.5, 2))^2 %>%
rowMeans(.) %>%
sqrt(.)
}
### initiate time and RMSE
time <- numeric(3)
RMSE <- matrix(0, 3, 5)
### conduct simulation for n = 200,500 and 1000
i <- 1
for (n in c(2,5,10) * 100) {
time[i] <- system.time(RMSE[i,] <- fit_n_times(n))/100 # average computing time
i <- i + 1
}
### update format for plotting
time <- data.frame(number_of_runs=c(2,5,10) * 100, time=time)
save(time, RMSE, file = 'fit_n_times.RData')
### plot time
plot(time, type ='b')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
RMSE$number_of_runs <- c(2,5,10) * 100
plot(NULL, ylab = 'RMSE', xlim=c(0, 4), ylim=c(min(RMSE), max(RMSE)))
lines(RMSE$number_of_runs, RMSE$mu1, col='red')
lines(RMSE$number_of_runs, RMSE$sigma1, col='orange')
lines(RMSE$number_of_runs, RMSE$mu2, col='black')
lines(RMSE$number_of_runs, RMSE$sigma2, col='blue')
lines(RMSE$number_of_runs, RMSE$theta, col='green')
legend( x = 'topright', legend = names(RMSE), pch=1,
col = c('red', 'orange', 'black', 'blue', 'green'))
### plot time
plot(time, type ='b')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
RMSE$number_of_runs <- c(2,5,10) * 100
plot(NULL, ylab = 'RMSE', xlim=c(0, 10^4), ylim=c(min(RMSE), max(RMSE)))
lines(RMSE$number_of_runs, RMSE$mu1, col='red')
lines(RMSE$number_of_runs, RMSE$sigma1, col='orange')
lines(RMSE$number_of_runs, RMSE$mu2, col='black')
lines(RMSE$number_of_runs, RMSE$sigma2, col='blue')
lines(RMSE$number_of_runs, RMSE$theta, col='green')
legend( x = 'topright', legend = names(RMSE), pch=1,
col = c('red', 'orange', 'black', 'blue', 'green'))
RMSE
load('fit_n_times.RData')
RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
RMSE
RMSE$number_of_runs <- c(2,5,10) * 100
RMSE
c(min(RMSE), max(RMSE)
)
load('fit_n_times.RData')
c(min(RMSE), max(RMSE))
### plot time
plot(time, type ='b')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
y_lim <- c(min(RMSE), max(RMSE))
RMSE$number_of_runs <- c(2,5,10) * 100
plot(NULL, ylab = 'RMSE', xlim=c(0, 10^3), ylim=y_lim)
lines(RMSE$number_of_runs, RMSE$mu1, col='red')
lines(RMSE$number_of_runs, RMSE$sigma1, col='orange')
lines(RMSE$number_of_runs, RMSE$mu2, col='black')
lines(RMSE$number_of_runs, RMSE$sigma2, col='blue')
lines(RMSE$number_of_runs, RMSE$theta, col='green')
legend( x = 'topright', legend = names(RMSE), pch=1,
col = c('red', 'orange', 'black', 'blue', 'green'))
load('fit_n_times.RData')
load('fit_n_times.RData')
### plot time
plot(time, type ='b')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
plot(NULL, xlab = 'number_of_runs', ylab = 'RMSE',
xlim=c(0, 10^3), ylim=c(min(RMSE), max(RMSE)))
lines(number_of_runs, RMSE$mu1, col='red')
load('fit_n_times.RData')
### plot time
plot(time, type ='b')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
plot(NULL, xlab = 'number_of_runs', ylab = 'RMSE',
xlim=c(0, 10^3), ylim=c(min(RMSE), max(RMSE)))
number_of_runs <- c(2,5,10) * 100
lines(number_of_runs, RMSE$mu1, col='red')
lines(number_of_runs, RMSE$sigma1, col='orange')
lines(number_of_runs, RMSE$mu2, col='black')
lines(number_of_runs, RMSE$sigma2, col='blue')
lines(number_of_runs, RMSE$theta, col='green')
legend( x = 'topright', legend = names(RMSE), pch=1,
col = c('red', 'orange', 'black', 'blue', 'green'))
load('fit_n_times.RData')
### plot time
plot(time, type ='b')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
plot(NULL, xlab = 'number_of_runs', ylab = 'RMSE',
xlim=c(0, 10^3), ylim=c(min(RMSE), max(RMSE)))
number_of_runs <- c(2,5,10) * 100
lines(number_of_runs, type ='b', RMSE$mu1, col='red')
lines(number_of_runs, type ='b', RMSE$sigma1, col='orange')
lines(number_of_runs, type ='b', RMSE$mu2, col='black')
lines(number_of_runs, type ='b', RMSE$sigma2, col='blue')
lines(number_of_runs, type ='b', RMSE$theta, col='green')
legend( x = 'topright', legend = names(RMSE), pch=1,
col = c('red', 'orange', 'black', 'blue', 'green'))
save(Vt, file = 'Vt.RData')
Pt <- 40000 * exp(-seq(100,200,10)/7)
results <- cbind(Pt, Vt, Pt < Vt)
results <- as.data.frame(results)
names(results) <- c('Price', 'Value', 'IfBuy')
rownames(results) <- seq(100,200,10)
results
Pt <- 40000 * exp(-seq(100,200,10)/7)
results <- cbind(Pt, Vt, Pt < Vt)
results <- as.data.frame(results)
names(results) <- c('P(t)', 'V(t)', 'P(t) < V(t)')
rownames(results) <- seq(100,200,10)
results
stargazer(results, title="A Handsome Table", header=T)
?stargazer
install.packages("stargazer")
library(stargazer)
knitr::opts_chunk$set(cache=TRUE,
message=FALSE, warning=FALSE,
fig.path='figs/',
cache.path = '_cache/',
fig.process = function(x) {
x2 = sub('-\\d+([.][a-z]+)$', '\\1', x)
if (file.rename(x, x2)) x2 else x
})
library(copula)
library(WVPlots)
library(gridExtra)
library(tidyverse)
library(stargazer)
Pt <- 40000 * exp(-seq(100,200,10)/7)
results <- cbind(Pt, Vt, Pt < Vt)
results <- as.data.frame(results)
names(results) <- c('P(t)', 'V(t)', 'P(t) < V(t)')
rownames(results) <- seq(100,200,10)
results
stargazer(results, title="A Handsome Table", header=T)
Pt <- 40000 * exp(-seq(100,200,10)/7)
results <- cbind(Pt, Vt, Pt < Vt)
results <- as.data.frame(results)
names(results) <- c('P(t)', 'V(t)', 'P(t) < V(t)')
rownames(results) <- seq(100,200,10)
results
stargazer(results, title="A Handsome Table", header=T)
plot(rownames(results) )
plot(results, type='b')
results
plot(results[,2], type='b')
plot(results[,'V(t)'], type='b')
plot(seq(100,200,10), results[,'V(t)'], type='b')
plot(seq(100,200,10), results[,2], type='b', ylab = 'V(t))
''
''
plot(seq(100,200,10), results[,2], type='b', ylab = 'V(t)')
plot(seq(100,200,10), results[,2], type='b', xlab = 't', ylab = 'V(t)')
V
t(V(t))
t(V)
View(V)
plot(V)
Vt_std <- colSds(V)
apply(V, 2, sd)
Vt_sd <- apply(V, 2, sd)
Vt_sd
names(Vt_sd)
names(Vt_sd) <- c(1,2)
Vt_sd
names(Vt_sd) <- seq(100,200,10)
Vt_sd
Vt_sd
t(Vt_sd)
stargazer(t(Vt_sd))
Vt
Vt_sd
data.frame(t=seq(100,200,10), Vt_sd=Vt_sd)
stargazer(data.frame(t=seq(100,200,10), Vt_sd=Vt_sd), title="Standard Deviation of P(t)", header=T)
k <- length(data$ID) # number of data points for each simulation run
B <- 10^5 # number of simulation runs
### simulated k*B data points to save time
simulated_data <- rmycopula(k*B, est$est1[1], est$est1[2], est$est2[1], est$est2[2], est$est3)
V <- c()
for (i in 1:B){
temp_data <- simulated_data[(k*(i-1)+1):(k*i),] # simulated data for current run
total_claim <- rowSums(temp_data)
### calculate V(t) for t=100,110,…,200
V_new <- sapply(seq(100,200,10), function(t) sum(total_claim[total_claim > t]))
V <- rbind(V,V_new)
}
Vt <- colMeans(V) # mean
Vt_sd <- apply(V, 2, sd) #sd
save(Vt, Vt_sd, file = 'Vt.RData')
rm(V)
load('Vt.RData')
Pt <- 40000 * exp(-seq(100,200,10)/7)
results <- cbind(Pt, Vt, Pt < Vt)
results <- as.data.frame(results)
names(results) <- c('P(t)', 'V(t)', 'P(t) < V(t)')
rownames(results) <- seq(100,200,10)
stargazer(results, title="P(t) and V(t)", header=T)
```S
Pt <- 40000 * exp(-seq(100,200,10)/7)
results <- cbind(Pt, Vt, Pt < Vt)
results <- as.data.frame(results)
names(results) <- c('P(t)', 'V(t)', 'P(t) < V(t)')
rownames(results) <- seq(100,200,10)
stargazer(results, title="P(t) and V(t)", header=T)
results
Pt <- 40000 * exp(-seq(100,200,10)/7)
results <- cbind(Pt, Vt, Pt < Vt)
results <- as.data.frame(results)
names(results) <- c('P(t)', 'V(t)', 'P(t) < V(t)')
rownames(results) <- seq(100,200,10)
stargazer(results, title="P(t) and V(t)", header=T)
plot(seq(100,200,10), results[,2], type='b', xlab = 't', ylab = 'V(t)')
stargazer(data.frame(t=seq(100,200,10), Vt_sd=Vt_sd), title="Standard Deviation of P(t)", header=T)
Vt_sd
results
### new parameters est2 for importance sampling
est2 <- est
### setting higher mu's to make the events more probable
est2$est1[1] <- 4
est2$est2[1] <- 3
dmycopula <- function(Y, est) {
##############################
# This function calculate the density of the copula model at Y
# Y: the observed data with X1 and X2
##############################
x1 <- Y[,1]; x2 <- Y[,2]
u1 <- plnorm(x1, meanlog = est$est1[1], sdlog = est$est1[2])
u2 <- plnorm(x2, meanlog = est$est2[1], sdlog = est$est2[2])
dlnorm(x1, est$est1[1], est$est1[2]) *
dlnorm(x2, est$est1[1], est$est2[2]) *
dCopula(cbind(u1, u2), joeCopula(est$est3))
}
simulated_data2 <- rmycopula(k*B, est2$est1[1], est2$est1[2],
est2$est2[1], est2$est2[2], est2$est3)
V2 <- c()
for (i in 1:B){
Y <- simulated_data2[(k*(i-1)+1):(k*i),] # get Y for dmycopula
total_claim <- rowSums(Y)
### importance sampling
density_div <- dmycopula(Y, est) / dmycopula(Y, est2)
V_new <- sapply(seq(100,200,10), function(t) sum(total_claim[total_claim > t]*
density_div[total_claim > t]))
V2 <- rbind(V2,V_new)
}
View(estimate)
Vt2 <- colMeans(V2) # mean
Vt_sd2 <- apply(V, 2, sd) #sd
Vt_sd2 <- apply(V2, 2, sd)
save(Vt2, Vt_sd2, file = 'Vt2.RData')
rm(V2, simulated_data2)
results2 <- cbind(Pt, Vt2, Pt < Vt2)
results2 <- as.data.frame(results2)
names(results2) <- c('P(t)', 'V(t)', 'P(t) < V(t)')
rownames(results2) <- seq(100,200,10)
stargazer(results2, title="P(t) and V(t) based on importance sampling", header=T)
plot(seq(100,200,10), Vt2, type='b')
lines(seq(100,200,10), Pt, type='b', col='red')
plot(seq(100,200,10), Vt2, xlab ='t', ylab ='P/V', type='b')
lines(seq(100,200,10), Pt, type='b', col='red')
legend( x = 'topright', legend = c('Vt','Pt'), pch=1,
col = c('black', 'red'))
results2
Vt_sd2
Vt_sd
#### Empirical bootstrap algorithm
B <- 1000 # number of bootstrap runs
set.seed(1000)
Vt_boot <- t(sapply(1:B, function(b){
### draw samples from the observed data; using empirical bootstrapping
data_boot <- data[sample(1:length(data$ID), replace = TRUE),]
x1_boot <- data_boot[,1]; x2_boot <- data_boot[,2]
### using the above-mentioned estimate function to get estimated parameters
est_boot <- estimate(x1_boot,x2_boot)
### create est2 for importance sampling
est2_boot <- est_boot
est2_boot$est1[1] <- est2_boot$est1[1]+1
est2_boot$est2[1] <- est2_boot$est1[1]+0.1
V <- c()
### 1000 bootstrapping simulations using importance sampling
for (i in 1:10^5){
Y <- rmycopula(length(data$ID), est2$est1[1], est2$est1[2],
est2$est2[1], est2$est2[2], est2$est3)
total_claim <- rowSums(Y)
density_div <- dmycopula(Y, est) / dmycopula(Y, est2)
V_new <- sapply(seq(100,200,10), function(t) sum(total_claim[total_claim > t]*
density_div[total_claim > t]))
V <- rbind(V,V_new)
}
return(t(colMeans(V)))
}))
#### Empirical bootstrap algorithm
B <- 1000 # number of bootstrap runs
set.seed(1000)
Vt_boot <- t(sapply(1:B, function(b){
### draw samples from the observed data; using empirical bootstrapping
data_boot <- data[sample(1:length(data$ID), replace = TRUE),]
x1_boot <- data_boot[,1]; x2_boot <- data_boot[,2]
### using the above-mentioned estimate function to get estimated parameters
est_boot <- estimate(x1_boot,x2_boot)
### create est2 for importance sampling
est2_boot <- est_boot
est2_boot$est1[1] <- est2_boot$est1[1]+1
est2_boot$est2[1] <- est2_boot$est1[1]+0.1
V3 <- c()
### 1000 bootstrapping simulations using importance sampling
for (i in 1:10^5){
Y <- rmycopula(length(data$ID), est2$est1[1], est2$est1[2],
est2$est2[1], est2$est2[2], est2$est3)
total_claim <- rowSums(Y)
density_div <- dmycopula(Y, est) / dmycopula(Y, est2)
V_new <- sapply(seq(100,200,10), function(t) sum(total_claim[total_claim > t]*
density_div[total_claim > t]))
V3 <- rbind(V3,V_new)
}
return(t(colMeans(V3)))
}))
rm(simulated_data)
#### Empirical bootstrap algorithm
B <- 2#1000 # number of bootstrap runs
set.seed(1000)
system.time(
Vt_boot <- t(sapply(1:B, function(b){
### draw samples from the observed data; using empirical bootstrapping
data_boot <- data[sample(1:length(data$ID), replace = TRUE),]
x1_boot <- data_boot[,1]; x2_boot <- data_boot[,2]
### using the above-mentioned estimate function to get estimated parameters
est_boot <- estimate(x1_boot,x2_boot)
### create est2 for importance sampling
est2_boot <- est_boot
est2_boot$est1[1] <- est2_boot$est1[1]+1
est2_boot$est2[1] <- est2_boot$est1[1]+0.1
V3 <- c()
### 1000 bootstrapping simulations using importance sampling
for (i in 1:10^5){
Y <- rmycopula(length(data$ID), est2$est1[1], est2$est1[2],
est2$est2[1], est2$est2[2], est2$est3)
total_claim <- rowSums(Y)
density_div <- dmycopula(Y, est) / dmycopula(Y, est2)
V_new <- sapply(seq(100,200,10), function(t) sum(total_claim[total_claim > t]*
density_div[total_claim > t]))
V3 <- rbind(V3,V_new)
}
return(t(colMeans(V3)))
})))
3482/60
View(Vt_boot)
k
knitr::opts_chunk$set(cache=TRUE,
message=FALSE, warning=FALSE,
fig.path='figs/',
cache.path = '_cache/',
fig.process = function(x) {
x2 = sub('-\\d+([.][a-z]+)$', '\\1', x)
if (file.rename(x, x2)) x2 else x
})
library(copula)
library(WVPlots)
library(gridExtra)
library(tidyverse)
library(stargazer)
options(digits.secs = 3)
load('fit_n_times.RData')
### plot time
plot(time, type ='b')
### plot RMSE
RMSE <- as.data.frame(RMSE)
names(RMSE) <- c('mu1', 'sigma1', 'mu2', 'sigma2', 'theta')
plot(NULL, xlab = 'number_of_runs', ylab = 'RMSE',
xlim=c(0, 10^3), ylim=c(min(RMSE), max(RMSE)))
number_of_runs <- c(2,5,10) * 100
lines(number_of_runs, type ='b', RMSE$mu1, col='red')
lines(number_of_runs, type ='b', RMSE$sigma1, col='orange')
lines(number_of_runs, type ='b', RMSE$mu2, col='black')
lines(number_of_runs, type ='b', RMSE$sigma2, col='blue')
lines(number_of_runs, type ='b', RMSE$theta, col='green')
legend( x = 'topright', legend = names(RMSE), pch=1,
col = c('red', 'orange', 'black', 'blue', 'green'))
B <- 10^5 # number of simulation runs
### simulated B data points to save time
simulated_data <- rmycopula(B, est$est1[1], est$est1[2], est$est2[1], est$est2[2], est$est3)
total_claim <- rowSums(simulated_data) # x1 + x2
total_claim <- matrix(total_claim, nrow=k)
V <- sapply(seq(100,200,10), function(t)
{apply(total_claim, 2, function(x) mean(x[x > t]))})
V[is.na(V)] <- 0 # replace NA with zeros
Vt <- colMeans(V) # mean for each client
Vt_sd <- apply(V, 2, sd) # sd
